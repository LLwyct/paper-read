## 摘要
我们提出了一种自动迭代的抽象-精细化方法，其中初始抽象模型是通过自动分析程序中的控制结构生成的，以便进行验证。抽象模型可能允许错误的或是虚假的反例。我们设计了新的符号技术，对这些反例进行了分析，并相应地精细化了抽象模型。由于使用了抽象函数，精细化算法使抽象状态空间的大小保持较小，抽象函数区分了每个程序变量的多个抽象程度。我们描述了这种方法在NuSMV中的实现。实际实验包括大型富士通IP核心设计，大约500个锁存器和10000行SMV代码，证实了我们的方法的有效性。

## 1.介绍
**状态爆炸问题仍是将模型用于检测大型工业设计的一个障碍。**
抽象肯定是解决这个问题的最关键的技术。事实上，它对于验证工业复杂性的设计至关重要。目前，抽象是一种手工过程，往往需要大量的时间、精力。为了在工业中更广泛地使用形式化检测，需要自动化技术来生成抽象。在本文中，我们描述了基于ACTL* 规范的自动抽象技术，该技术基于对程序中出现的公式结构的分析。（ACTL* 是CTL*的一个片段，它只允许通过路径进行通用量化）。
**通常，我们的技术计算原始程序的上近似值。 因此，当抽象模型中的规范成立时，在具体设计中也是如此。 但是，如果抽象模型中的规范是错误的，则反例可能是近似中某些行为的结果，而原始模型中不存在这种行为。**
当这种情况发生时，有必要去精细化（改进）这个抽象，以便消除导致错误反例的行为。这篇论文主要贡献是提出了一种高效的自动精细化（修正）技术，该技术使用从错误反例中获得的信息。
**这个精细化算法保持了抽象状态空间很小，由于使用了抽象函数，它可以区分每个程序变量的多个抽象程度。**
实际实验包括大型富士通IP核心设计，大约500个锁存器和10000行SMV代码，这些都证明了我们成果的竞争力。 虽然我们当前的实现基于NuSMV，但它原则上不限于SMV的输入语言，并且可以应用于其他语言。

我们的论文遵循Clarke，Grumberg和Long建立的总体框架[10]。我们假设读者对该框架有一定的了解。在我们的方法中，原子公式是从描述模型的程序中自动提取的。 原子公式类似于Graf和Saidi [13]以及后来[11,20]中用于抽象的谓词。但是，我们不是使用原子公式来生成抽象的全局转换系统，而是使用它们来构造一个显式的抽象函数。
**抽象函数保留原子公式之间的逻辑关系，而不是将它们视为独立命题。**
初始抽象模型是通过将[8,10]中提出的存在抽象技术进行改编并应用于我们的框架而构建的。然后，使用传统的模型检查器来确定ACTL*属性是否保留在抽象模型中。
**如果答案是肯定的，那么实际模型也满足了属性。如果答案为否，那么模型检查器会生成一个反例。由于抽象模型比实际模型具有更多行为，因此抽象反例可能无效。**
我们认为这个反例是虚假的。这种抽象技术也被称为假否定技术。

在我们的方法中，我们提供了一种新的符号算法来决定一个抽象反例是否是虚假的。如果这个抽象反例不是虚假的，我们会把它报告给用户并停止算法。如果抽象反例是虚假的，必须精细化抽象函数来消除它。在我们的方法中，我们确定了抽象反例的最短前缀（prefix），它与实际模型的实际跟踪（trace）不对应。
**这个前缀（prefix）中的最后一个抽象状态被分割成减少了抽象（less abstract）的状态，以便消除虚假的反例**
因此，获得了更加精细化的抽象函数。注意，可能有很多方法来分割抽象状态;每个都决定了抽象函数的不同的精细程度。
**这期望获得最粗糙（粗粒度）的改进来消除反例，因为这对应于适合于验证的最小抽象模型。（这里我理解的是：现在要找到一个办法来改进或者说是精细化抽象函数，但是这种改进最好是很粗糙的，因为这种低程度的改进有利于验证最小的抽象模型？我暂时先这么理解吧）**
然而，我们证明找到一个粗粒度的精细化方法是一个NPhard问题。因此，我们使用了一个多项式复杂度的算法，这个算法给出了一个可能不是最优的解，但是依然足够精细化的抽象函数。我们的启发式算法的适用性由我们的实验证实。使用以这种方式获得的精细化后的抽象函数，一个新的抽象模型被构建出来并重复整个过程。我们的方法对于ACTL* 的片段是完整的，其具有路径或循环的反例，也就是说，我们保证找到有效的反例或证明系统满足它期望的属性。 原则上，我们的方法可以扩展到所有的ACTL*。

从Kurshan的局部化减少开始，许多其他研究人员已经使用反例来精细化抽象模型[14]。他将并发系统建模为n个L-process（L1~Ln）的组合（L-process在[14]中被详细描述）。局部化减少是一种迭代技术，从一小部分相关L-过程开始，这些过程在拓扑上接近变量依赖图中的规范。
**所有其他程序变量都使用非确定性赋值进行抽象。 如果发现反例是虚假的，则添加额外的变量以消除反例。**
启发式地选择这些变量也要从变量依赖图来获取信息。请注意，局部化减少要么保持变量不变，要么通过确定性赋值替换它。一个类似的方法已经在[2,15]中被Balarin阐述。在我们的方法中，抽象函数利用了出现在程序控制结构中的原子公式中出现的变量之间的逻辑关系。而且，我们使用抽象函数的方式可以区分每个变量的多个抽象程度。因此，在精细化（改进）步骤中，仅需要对抽象函数进行非常小的局部变化，并且抽象模型仍然相对较小。

Lind-Nielson和Andersen [17]最近提出了另一种改进技术。他们的模型检查器使用上下近似值来处理所有CTL。它们的近似技术使他们能够避免在每次精细化后重新检查整个模型，同时保证完整性。与[2,14]中一样，变量依赖图既用于获取初始的抽象，也用于精细化过程。还以类似的方式执行变量抽象。因此，我们的抽象-精细化方法与其技术的关系基本上与它与传统的局部减少相关。

许多其他论文[16,18,19]提出了用于CTL模型检查的抽象-精细化技术。但是，这些论文并没有使用反例来重新定义抽象。我们相信这些论文中描述的方法与我们的技术正交，甚至可以与我们的技术相结合，以获得更好的性能。Govindaraju和Dill[12]最近提出的技术可能是这个方向的起点，因为它也试图在一个抽象的反例中识别出第一个虚假状态。它随机选择对应于第一个虚假状态的具体状态，并尝试构建一个真实的反例，从过渡关系下的该状态图像开始。本文仅讨论安全属性和路径反例。 它没有描述如何使用循环反例检查活动属性。
**此外，我们的方法不使用随机选择来扩展反例; 相反，它分析了造成虚假反例的原因，并使用这些信息来指导精细化过程。**
在完整版中将给出与相关工作的更详细比较。总而言之，我们的技术与以前的工作相比具有许多优点：

1. 我们的技术对于ACTL*中的重要片段来说是完整的。
2. **初始的抽象和精细化的步骤是有效率的并且完全自动化的。所有的算法都是符号化的（symbolic）.**
3. 在于其他方法的比较中，比如局部减小，我们可以区分每个变量的更多抽象程度。因此。精细化中的改变对于我们的方法更加潜在地合适（ Thus, the changes in the reﬁnement are potentially ﬁner in our approach.）。
4. **保证改进过程可以消除虚假的反例，同时保持抽象模型的状态空间依旧很小。**

我们在NuSMV[6]中实现了我们的新方法，并将其应用于许多基准设计[6]。此外，我们还用它来调试富士通开发的大型IP核心[1]。该设计具有约350个符号变量，其对应于约500个锁存器。在使用我们的方法之前，我们在NuSMV中实现了减少影响的锥体[8]，以增强其检查大型模型的能力。我们的增强版NuSMV和最近由Yang[23]开发的SMV版本都无法验证富士通IP核心设计。但是，通过使用我们的新技术，我们能够在设计中发现一个细小的错误。我们的程序自动抽象出144个符号变量，并执行了三个改进步骤。 目前，我们正在评估将这个方法运用在其他复杂工业设计上。

本文的结构如下：第2节给出了整篇论文中使用的基本定义和术语。第3节给出了我们方法的一般概述。第4节提供了抽象-精细化算法的详细描述。第5节描述了实现的性能改进。实验结果见第6节。未来的研究将在第7节讨论。